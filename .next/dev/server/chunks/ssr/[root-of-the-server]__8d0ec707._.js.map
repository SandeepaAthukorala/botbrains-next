{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/src/lib/categoryStorage.ts"],"sourcesContent":["import { db } from './firebase';\r\nimport { collection, doc, getDoc, getDocs, setDoc, updateDoc, deleteDoc, query, where, orderBy, getCountFromServer } from 'firebase/firestore';\r\nimport type { Category } from '@/types';\r\n\r\nconst COLLECTION = 'categories';\r\n\r\n/**\r\n * Generate a unique ID for categories\r\n */\r\nfunction generateId(): string {\r\n    return `cat-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Create a new category\r\n */\r\nexport async function createCategory(\r\n    name: string,\r\n    color: string,\r\n    description?: string,\r\n    workspaceId?: string\r\n): Promise<Category> {\r\n    const id = generateId();\r\n    const category: Category = {\r\n        id,\r\n        name,\r\n        color,\r\n        description,\r\n        workspaceId,\r\n        created_at: new Date().toISOString(),\r\n    };\r\n\r\n    await setDoc(doc(db, COLLECTION, id), category);\r\n    return category;\r\n}\r\n\r\n/**\r\n * Get all categories\r\n */\r\nexport async function getAllCategories(workspaceId?: string): Promise<Category[]> {\r\n    let q;\r\n    if (workspaceId) {\r\n        q = query(collection(db, COLLECTION), where('workspaceId', '==', workspaceId), orderBy('name'));\r\n    } else {\r\n        q = query(collection(db, COLLECTION), orderBy('name'));\r\n    }\r\n\r\n    // Fallback if index not created yet:\r\n    // If orderBy fails due to missing index, we might need to catch and sort in memory.\r\n    // For now assuming we can fix indexes or run in dev mode.\r\n    // Actually, simple queries without composite fields don't strictly need indexes for some cases, \r\n    // but 'where'+'orderBy' usually does.\r\n    // To be safe and simple for migration, we can fetch then sort in client if we expect low volume.\r\n    // But let's try strict constraints first.\r\n\r\n    try {\r\n        const querySnapshot = await getDocs(q);\r\n        return querySnapshot.docs.map(doc => doc.data() as Category);\r\n    } catch (e: any) {\r\n        // Fallback: fetch without sort if index error\r\n        if (e.code === 'failed-precondition') {\r\n            const fallbackQ = workspaceId\r\n                ? query(collection(db, COLLECTION), where('workspaceId', '==', workspaceId))\r\n                : collection(db, COLLECTION);\r\n            const snap = await getDocs(fallbackQ);\r\n            const docs = snap.docs.map(doc => doc.data() as Category);\r\n            return docs.sort((a, b) => a.name.localeCompare(b.name));\r\n        }\r\n        throw e;\r\n    }\r\n}\r\n\r\n/**\r\n * Get a single category by ID\r\n */\r\nexport async function getCategory(id: string): Promise<Category | undefined> {\r\n    const docRef = doc(db, COLLECTION, id);\r\n    const docSnap = await getDoc(docRef);\r\n\r\n    if (docSnap.exists()) {\r\n        return docSnap.data() as Category;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Update a category\r\n */\r\nexport async function updateCategory(\r\n    id: string,\r\n    updates: Partial<Omit<Category, 'id' | 'created_at'>>\r\n): Promise<void> {\r\n    const docRef = doc(db, COLLECTION, id);\r\n    await updateDoc(docRef, updates);\r\n}\r\n\r\n/**\r\n * Delete a category\r\n */\r\nexport async function deleteCategory(id: string): Promise<void> {\r\n    await deleteDoc(doc(db, COLLECTION, id));\r\n}\r\n\r\n/**\r\n * Get usage count for a category (how many prompts use it)\r\n */\r\nexport async function getCategoryUsageCount(categoryName: string, workspaceId?: string): Promise<number> {\r\n    // Note: This relies on prompts having the category NAME stored, which is brittle if names change.\r\n    // Ideally prompts should store categoryId.\r\n    // Assuming legacy structure stores name.\r\n\r\n    let q = query(collection(db, 'prompts'), where('category', '==', categoryName));\r\n    if (workspaceId) {\r\n        q = query(q, where('workspaceId', '==', workspaceId));\r\n    }\r\n\r\n    const snapshot = await getCountFromServer(q);\r\n    return snapshot.data().count;\r\n}\r\n\r\n/**\r\n * Get category by name\r\n */\r\nexport async function getCategoryByName(name: string, workspaceId?: string): Promise<Category | undefined> {\r\n    let q = query(collection(db, COLLECTION), where('name', '==', name));\r\n    if (workspaceId) {\r\n        q = query(q, where('workspaceId', '==', workspaceId));\r\n    }\r\n\r\n    const querySnapshot = await getDocs(q);\r\n    if (!querySnapshot.empty) {\r\n        return querySnapshot.docs[0].data() as Category;\r\n    }\r\n    return undefined;\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 119, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/src/lib/keywordStorage.ts"],"sourcesContent":["import { db } from './firebase';\r\nimport { collection, doc, getDoc, getDocs, setDoc, deleteDoc, query, where, orderBy } from 'firebase/firestore';\r\nimport type { Keyword } from '@/types';\r\n\r\nconst COLLECTION = 'keywords';\r\n\r\n/**\r\n * Generate a unique ID for keywords\r\n */\r\nfunction generateId(): string {\r\n    return `kw-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Create a new keyword\r\n */\r\nexport async function createKeyword(name: string, workspaceId?: string): Promise<Keyword> {\r\n    const id = generateId();\r\n    const keyword: Keyword = {\r\n        id,\r\n        name,\r\n        workspaceId,\r\n        created_at: new Date().toISOString(),\r\n    };\r\n\r\n    await setDoc(doc(db, COLLECTION, id), keyword);\r\n    return keyword;\r\n}\r\n\r\n/**\r\n * Get all keywords\r\n */\r\nexport async function getAllKeywords(workspaceId?: string): Promise<Keyword[]> {\r\n    let q;\r\n    if (workspaceId) {\r\n        q = query(collection(db, COLLECTION), where('workspaceId', '==', workspaceId), orderBy('name'));\r\n    } else {\r\n        q = query(collection(db, COLLECTION), orderBy('name'));\r\n    }\r\n\r\n    try {\r\n        const querySnapshot = await getDocs(q);\r\n        return querySnapshot.docs.map(doc => doc.data() as Keyword);\r\n    } catch (e: any) {\r\n        if (e.code === 'failed-precondition') {\r\n            const fallbackQ = workspaceId\r\n                ? query(collection(db, COLLECTION), where('workspaceId', '==', workspaceId))\r\n                : collection(db, COLLECTION);\r\n            const snap = await getDocs(fallbackQ);\r\n            const docs = snap.docs.map(doc => doc.data() as Keyword);\r\n            return docs.sort((a, b) => a.name.localeCompare(b.name));\r\n        }\r\n        throw e;\r\n    }\r\n}\r\n\r\n/**\r\n * Get a single keyword by ID\r\n */\r\nexport async function getKeyword(id: string): Promise<Keyword | undefined> {\r\n    const docRef = doc(db, COLLECTION, id);\r\n    const docSnap = await getDoc(docRef);\r\n\r\n    if (docSnap.exists()) {\r\n        return docSnap.data() as Keyword;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Delete a keyword\r\n */\r\nexport async function deleteKeyword(id: string): Promise<void> {\r\n    await deleteDoc(doc(db, COLLECTION, id));\r\n}\r\n\r\n/**\r\n * Get usage count for a keyword (how many prompts use it)\r\n */\r\nexport async function getKeywordUsageCount(keywordName: string, workspaceId?: string): Promise<number> {\r\n    let q = query(collection(db, 'prompts'));\r\n    if (workspaceId) {\r\n        q = query(q, where('workspaceId', '==', workspaceId));\r\n    }\r\n\r\n    // Firestore lacks array-contains count efficiently without index or read.\r\n    // Fetching all prompts in workspace to count is safe-ish for small apps.\r\n    // 'array-contains' query is better:\r\n\r\n    const countQ = query(q, where('keywords', 'array-contains', keywordName));\r\n    const snapshot = await getDocs(countQ); // getCountFromServer works on array-contains? Yes.\r\n    return snapshot.size;\r\n}\r\n\r\n/**\r\n * Get keyword by name\r\n */\r\nexport async function getKeywordByName(name: string, workspaceId?: string): Promise<Keyword | undefined> {\r\n    let q = query(collection(db, COLLECTION), where('name', '==', name));\r\n    if (workspaceId) {\r\n        q = query(q, where('workspaceId', '==', workspaceId));\r\n    }\r\n\r\n    const querySnapshot = await getDocs(q);\r\n    if (!querySnapshot.empty) {\r\n        return querySnapshot.docs[0].data() as Keyword;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Get all unique keywords from prompts (for autocomplete)\r\n */\r\nexport async function getAllUsedKeywords(workspaceId?: string): Promise<string[]> {\r\n    // This is expensive in multiple ways on Firestore.\r\n    // Better to maintain a 'keywords' collection (which we do now).\r\n    // So this function might just alias getAllKeywords() map name.\r\n\r\n    const keywords = await getAllKeywords(workspaceId);\r\n    return keywords.map(k => k.name);\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 222, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/src/lib/exportImport.ts"],"sourcesContent":["import JSZip from 'jszip';\r\nimport { saveAs } from 'file-saver';\r\nimport matter from 'gray-matter';\r\nimport type { Prompt, Workspace, Category, Keyword } from '@/types';\r\nimport { getAllPrompts } from './storage';\r\nimport { getWorkspacesByProfile } from './workspaceStorage';\r\nimport { getAllCategories } from './categoryStorage';\r\nimport { getAllKeywords } from './keywordStorage';\r\n\r\n// ============================================================================\r\n// TYPES\r\n// ============================================================================\r\n\r\nexport interface ExportManifest {\r\n    version: string;\r\n    exportedAt: string;\r\n    appVersion: string;\r\n    profileId: string;\r\n    counts: {\r\n        workspaces: number;\r\n        prompts: number;\r\n        categories: number;\r\n        keywords: number;\r\n    };\r\n}\r\n\r\nexport interface WorkspaceExportData {\r\n    workspace: Workspace;\r\n    prompts: Prompt[];\r\n}\r\n\r\nexport interface FullExportData {\r\n    manifest: ExportManifest;\r\n    workspaces: WorkspaceExportData[];\r\n    categories: Category[];\r\n    keywords: Keyword[];\r\n}\r\n\r\n// ============================================================================\r\n// UTILITIES\r\n// ============================================================================\r\n\r\n/**\r\n * Sanitize a string for use as a folder/file name\r\n * - Lowercase\r\n * - Replace spaces and special chars with hyphens\r\n * - Max 50 characters\r\n * - Remove leading/trailing hyphens\r\n */\r\nexport function sanitizeFolderName(name: string): string {\r\n    return name\r\n        .toLowerCase()\r\n        .trim()\r\n        .replace(/[^a-z0-9]+/g, '-') // Replace non-alphanumeric with hyphens\r\n        .replace(/^-+|-+$/g, '') // Remove leading/trailing hyphens\r\n        .slice(0, 50); // Max 50 chars\r\n}\r\n\r\n/**\r\n * Generate a unique folder name by appending -1, -2, etc if duplicates exist\r\n */\r\nexport function generateUniqueFolderName(baseName: string, existingNames: Set<string>): string {\r\n    let sanitized = sanitizeFolderName(baseName);\r\n    let uniqueName = sanitized;\r\n    let counter = 1;\r\n\r\n    while (existingNames.has(uniqueName)) {\r\n        uniqueName = `${sanitized}-${counter}`;\r\n        counter++;\r\n    }\r\n\r\n    existingNames.add(uniqueName);\r\n    return uniqueName;\r\n}\r\n\r\n// ============================================================================\r\n// MARKDOWN GENERATION\r\n// ============================================================================\r\n\r\n/**\r\n * Generate Markdown file with YAML frontmatter for a prompt\r\n */\r\nexport function generatePromptMarkdown(prompt: Prompt): string {\r\n    // Frontmatter data (subset of prompt data that's human-readable)\r\n    const frontmatter = {\r\n        title: prompt.title,\r\n        type: prompt.type,\r\n        category: prompt.category,\r\n        tags: prompt.tags,\r\n        keywords: prompt.keywords,\r\n        description: prompt.performance.notes || '',\r\n        isFavorite: prompt.isFavorite || false,\r\n    };\r\n\r\n    // Manually generate YAML frontmatter (avoid gray-matter.stringify which uses Buffer)\r\n    const yamlLines = ['---'];\r\n\r\n    // Add each frontmatter field\r\n    for (const [key, value] of Object.entries(frontmatter)) {\r\n        if (Array.isArray(value)) {\r\n            if (value.length === 0) {\r\n                yamlLines.push(`${key}: []`);\r\n            } else {\r\n                yamlLines.push(`${key}:`);\r\n                value.forEach(item => {\r\n                    yamlLines.push(`  - ${JSON.stringify(item)}`);\r\n                });\r\n            }\r\n        } else if (typeof value === 'string') {\r\n            // Escape strings with colons or special characters\r\n            const needsQuotes = value.includes(':') || value.includes('#') || value.includes('\"');\r\n            yamlLines.push(`${key}: ${needsQuotes ? JSON.stringify(value) : value}`);\r\n        } else {\r\n            yamlLines.push(`${key}: ${value}`);\r\n        }\r\n    }\r\n\r\n    yamlLines.push('---');\r\n    yamlLines.push('');\r\n    yamlLines.push(prompt.prompt_template);\r\n\r\n    return yamlLines.join('\\n');\r\n}\r\n\r\n// ============================================================================\r\n// EXPORT FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Export all data for a profile\r\n */\r\nexport async function exportAllData(profileId: string): Promise<FullExportData> {\r\n    console.log('üîÑ Starting export for profile:', profileId);\r\n\r\n    // Fetch all workspaces for this profile\r\n    const workspaces = await getWorkspacesByProfile(profileId);\r\n    console.log(`üìä Found ${workspaces.length} workspaces`);\r\n\r\n    // Fetch prompts for each workspace\r\n    const workspaceData: WorkspaceExportData[] = [];\r\n    let totalPrompts = 0;\r\n\r\n    for (const workspace of workspaces) {\r\n        const prompts = await getAllPrompts(workspace.id);\r\n        totalPrompts += prompts.length;\r\n        workspaceData.push({\r\n            workspace,\r\n            prompts,\r\n        });\r\n        console.log(`  ‚úÖ Workspace \"${workspace.name}\": ${prompts.length} prompts`);\r\n    }\r\n\r\n    // Fetch all categories and keywords\r\n    const categories = await getAllCategories();\r\n    const keywords = await getAllKeywords();\r\n\r\n    console.log(`üìã Total: ${totalPrompts} prompts, ${categories.length} categories, ${keywords.length} keywords`);\r\n\r\n    // Create manifest\r\n    const manifest: ExportManifest = {\r\n        version: '1.0.0',\r\n        exportedAt: new Date().toISOString(),\r\n        appVersion: '1.0.0', // TODO: Get from package.json\r\n        profileId,\r\n        counts: {\r\n            workspaces: workspaces.length,\r\n            prompts: totalPrompts,\r\n            categories: categories.length,\r\n            keywords: keywords.length,\r\n        },\r\n    };\r\n\r\n    return {\r\n        manifest,\r\n        workspaces: workspaceData,\r\n        categories,\r\n        keywords,\r\n    };\r\n}\r\n\r\n/**\r\n * Create a ZIP archive from export data\r\n */\r\nexport async function createExportArchive(data: FullExportData): Promise<Blob> {\r\n    const zip = new JSZip();\r\n\r\n    // Add manifest at root\r\n    zip.file('manifest.json', JSON.stringify(data.manifest, null, 2));\r\n\r\n    // Add global categories and keywords\r\n    zip.file('categories.json', JSON.stringify(data.categories, null, 2));\r\n    zip.file('keywords.json', JSON.stringify(data.keywords, null, 2));\r\n\r\n    // Track folder names to ensure uniqueness\r\n    const workspaceFolderNames = new Set<string>();\r\n\r\n    // Process each workspace\r\n    for (const { workspace, prompts } of data.workspaces) {\r\n        const workspaceFolderName = generateUniqueFolderName(\r\n            `workspace-${workspace.name}`,\r\n            workspaceFolderNames\r\n        );\r\n\r\n        // Add workspace config.json\r\n        zip.file(\r\n            `${workspaceFolderName}/config.json`,\r\n            JSON.stringify(workspace, null, 2)\r\n        );\r\n\r\n        // Track prompt folder names within this workspace\r\n        const promptFolderNames = new Set<string>();\r\n\r\n        // Add each prompt\r\n        for (const prompt of prompts) {\r\n            const promptFolderName = generateUniqueFolderName(\r\n                prompt.title,\r\n                promptFolderNames\r\n            );\r\n\r\n            const promptPath = `${workspaceFolderName}/prompts/${promptFolderName}`;\r\n\r\n            // Add content.md (human-readable)\r\n            const markdown = generatePromptMarkdown(prompt);\r\n            zip.file(`${promptPath}/content.md`, markdown);\r\n\r\n            // Add metadata.json (complete data)\r\n            zip.file(`${promptPath}/metadata.json`, JSON.stringify(prompt, null, 2));\r\n        }\r\n    }\r\n\r\n    console.log('üì¶ Generating ZIP archive...');\r\n    // Generate blob without using workers to avoid CSP blob: restrictions\r\n    const blob = await zip.generateAsync({\r\n        type: 'blob',\r\n        compression: 'DEFLATE',\r\n        compressionOptions: {\r\n            level: 6\r\n        }\r\n    });\r\n    console.log(`‚úÖ Archive created: ${(blob.size / 1024 / 1024).toFixed(2)} MB`);\r\n\r\n    return blob;\r\n}\r\n\r\n/**\r\n * Export and download all data as a ZIP file\r\n */\r\nexport async function exportAndDownload(profileId: string): Promise<void> {\r\n    try {\r\n        // Export data\r\n        const data = await exportAllData(profileId);\r\n\r\n        // Create ZIP\r\n        const blob = await createExportArchive(data);\r\n\r\n        // Generate filename with timestamp\r\n        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);\r\n        const filename = `infinite-viking-backup-${timestamp}.zip`;\r\n\r\n        // Trigger download\r\n        saveAs(blob, filename);\r\n\r\n        console.log(`‚úÖ Export complete: ${filename}`);\r\n    } catch (error) {\r\n        console.error('‚ùå Export failed:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// IMPORT FUNCTIONS\r\n// ============================================================================\r\n\r\n/**\r\n * Parse Markdown file with YAML frontmatter\r\n */\r\nexport function parseMarkdownWithFrontmatter(markdown: string): {\r\n    frontmatter: any;\r\n    content: string;\r\n} {\r\n    const parsed = matter(markdown);\r\n    return {\r\n        frontmatter: parsed.data,\r\n        content: parsed.content,\r\n    };\r\n}\r\n\r\n/**\r\n * Clear all workspace data for a profile (DESTRUCTIVE)\r\n * This deletes: workspaces, prompts, categories, keywords\r\n */\r\nexport async function clearAllWorkspaceData(profileId: string): Promise<void> {\r\n    console.log('‚ö†Ô∏è CLEARING ALL DATA for profile:', profileId);\r\n\r\n    const { deleteWorkspace } = await import('./workspaceStorage');\r\n    const workspaces = await getWorkspacesByProfile(profileId);\r\n\r\n    for (const workspace of workspaces) {\r\n        console.log(`  üóëÔ∏è Deleting workspace: ${workspace.name}`);\r\n        await deleteWorkspace(workspace.id);\r\n    }\r\n\r\n    console.log('‚úÖ All data cleared');\r\n}\r\n\r\n/**\r\n * Import a full archive from a ZIP blob\r\n */\r\nexport async function importFullArchive(zipBlob: Blob, profileId: string): Promise<void> {\r\n    console.log('üì• Starting import...');\r\n\r\n    try {\r\n        // Load ZIP\r\n        const zip = await JSZip.loadAsync(zipBlob);\r\n\r\n        // Read and validate manifest\r\n        const manifestFile = zip.file('manifest.json');\r\n        if (!manifestFile) {\r\n            throw new Error('Invalid backup: manifest.json not found');\r\n        }\r\n\r\n        const manifestText = await manifestFile.async('text');\r\n        const manifest: ExportManifest = JSON.parse(manifestText);\r\n        console.log('üìã Manifest loaded:', manifest);\r\n\r\n        // Validate version compatibility\r\n        if (manifest.version !== '1.0.0') {\r\n            console.warn('‚ö†Ô∏è Version mismatch. Current: 1.0.0, Archive:', manifest.version);\r\n        }\r\n\r\n        // Clear existing data (NUCLEAR OPTION)\r\n        await clearAllWorkspaceData(profileId);\r\n\r\n        // Import global data\r\n        const categoriesFile = zip.file('categories.json');\r\n        const keywordsFile = zip.file('keywords.json');\r\n\r\n        let categories: Category[] = [];\r\n        let keywords: Keyword[] = [];\r\n\r\n        if (categoriesFile) {\r\n            const categoriesText = await categoriesFile.async('text');\r\n            categories = JSON.parse(categoriesText);\r\n        }\r\n\r\n        if (keywordsFile) {\r\n            const keywordsText = await keywordsFile.async('text');\r\n            keywords = JSON.parse(keywordsText);\r\n        }\r\n\r\n        console.log(`üìä Importing ${categories.length} categories, ${keywords.length} keywords`);\r\n\r\n        // Import categories\r\n        const { createCategory } = await import('./categoryStorage');\r\n        for (const category of categories) {\r\n            await createCategory(category.name, category.color, category.description, category.workspaceId);\r\n        }\r\n\r\n        // Import keywords\r\n        const { createKeyword } = await import('./keywordStorage');\r\n        for (const keyword of keywords) {\r\n            await createKeyword(keyword.name, keyword.workspaceId);\r\n        }\r\n\r\n        // Import workspaces and prompts\r\n        const { createWorkspace } = await import('./workspaceStorage');\r\n        const { createPrompt } = await import('./storage');\r\n\r\n        const workspaceFolders = Object.keys(zip.files).filter(\r\n            (path) => path.startsWith('workspace-') && path.endsWith('/config.json')\r\n        );\r\n\r\n        console.log(`üìÅ Found ${workspaceFolders.length} workspace folders`);\r\n\r\n        for (const configPath of workspaceFolders) {\r\n            const configFile = zip.file(configPath);\r\n            if (!configFile) continue;\r\n\r\n            const configText = await configFile.async('text');\r\n            const workspaceData: Workspace = JSON.parse(configText);\r\n\r\n            console.log(`  üìÇ Importing workspace: ${workspaceData.name}`);\r\n\r\n            // Create workspace\r\n            const newWorkspace = await createWorkspace(\r\n                profileId,\r\n                workspaceData.name,\r\n                workspaceData.icon,\r\n                workspaceData.color,\r\n                workspaceData.description\r\n            );\r\n\r\n            // Find all prompts in this workspace\r\n            const workspaceFolder = configPath.replace('/config.json', '');\r\n            const promptFolders = Object.keys(zip.files).filter(\r\n                (path) =>\r\n                    path.startsWith(`${workspaceFolder}/prompts/`) &&\r\n                    path.endsWith('/metadata.json')\r\n            );\r\n\r\n            console.log(`    üìù Found ${promptFolders.length} prompts`);\r\n\r\n            for (const metadataPath of promptFolders) {\r\n                const metadataFile = zip.file(metadataPath);\r\n                if (!metadataFile) continue;\r\n\r\n                const metadataText = await metadataFile.async('text');\r\n                const promptData: Prompt = JSON.parse(metadataText);\r\n\r\n                // Create prompt with new workspace ID\r\n                const { id, created_at, updated_at, workspaceId, ...promptFields } = promptData;\r\n\r\n                await createPrompt(promptFields, newWorkspace.id);\r\n            }\r\n        }\r\n\r\n        console.log('‚úÖ Import complete!');\r\n    } catch (error) {\r\n        console.error('‚ùå Import failed:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n/**\r\n * Import from a file input\r\n */\r\nexport async function importFromFile(file: File, profileId: string): Promise<void> {\r\n    if (!file.name.endsWith('.zip')) {\r\n        throw new Error('Please select a .zip file');\r\n    }\r\n\r\n    const blob = new Blob([file], { type: 'application/zip' });\r\n    await importFullArchive(blob, profileId);\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 518, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/src/components/settings/EmergencyExportSection.tsx"],"sourcesContent":["import { useState } from 'react';\r\nimport { Download } from 'lucide-react';\r\nimport { exportAndDownload } from '@/lib/exportImport';\r\nimport { useProfileStore } from '@/store/useProfileStore';\r\nimport { useToast } from '@/hooks/useToast';\r\n\r\nexport function EmergencyExportSection() {\r\n    const [isExporting, setIsExporting] = useState(false);\r\n    const { currentProfile } = useProfileStore();\r\n    const toast = useToast();\r\n\r\n    const handleExport = async () => {\r\n        if (!currentProfile) {\r\n            toast.error('No active profile');\r\n            return;\r\n        }\r\n\r\n        setIsExporting(true);\r\n        try {\r\n            await exportAndDownload(currentProfile.id);\r\n            toast.success('Backup exported successfully!');\r\n        } catch (error) {\r\n            console.error('Export error:', error);\r\n            toast.error('Export failed. Check console for details');\r\n        } finally {\r\n            setIsExporting(false);\r\n        }\r\n    };\r\n\r\n    return (\r\n        <div className=\"glass rounded-lg p-6\">\r\n            <div className=\"flex items-start justify-between mb-4\">\r\n                <div>\r\n                    <h2 className=\"text-xl font-semibold text-text-primary mb-2\">\r\n                        Emergency Export\r\n                    </h2>\r\n                    <p className=\"text-text-muted text-sm\">\r\n                        Download a complete backup of all your workspaces, prompts, categories, and keywords.\r\n                        The backup is a ZIP file containing human-readable Markdown files and JSON data.\r\n                    </p>\r\n                </div>\r\n            </div>\r\n\r\n            <button\r\n                onClick={handleExport}\r\n                disabled={isExporting}\r\n                className=\"btn-primary flex items-center gap-2\"\r\n            >\r\n                <Download size={18} />\r\n                {isExporting ? 'Exporting...' : 'Export All Data'}\r\n            </button>\r\n\r\n            {isExporting && (\r\n                <div className=\"mt-4 flex items-center gap-2 text-text-muted text-sm\">\r\n                    <div className=\"animate-spin h-4 w-4 border-2 border-accent-primary border-t-transparent rounded-full\" />\r\n                    <span>Preparing backup archive...</span>\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAEO,SAAS;IACZ,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,wOAAQ,EAAC;IAC/C,MAAM,EAAE,cAAc,EAAE,GAAG,IAAA,yKAAe;IAC1C,MAAM,QAAQ,IAAA,2JAAQ;IAEtB,MAAM,eAAe;QACjB,IAAI,CAAC,gBAAgB;YACjB,MAAM,KAAK,CAAC;YACZ;QACJ;QAEA,eAAe;QACf,IAAI;YACA,MAAM,IAAA,sKAAiB,EAAC,eAAe,EAAE;YACzC,MAAM,OAAO,CAAC;QAClB,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,iBAAiB;YAC/B,MAAM,KAAK,CAAC;QAChB,SAAU;YACN,eAAe;QACnB;IACJ;IAEA,qBACI,qQAAC;QAAI,WAAU;;0BACX,qQAAC;gBAAI,WAAU;0BACX,cAAA,qQAAC;;sCACG,qQAAC;4BAAG,WAAU;sCAA+C;;;;;;sCAG7D,qQAAC;4BAAE,WAAU;sCAA0B;;;;;;;;;;;;;;;;;0BAO/C,qQAAC;gBACG,SAAS;gBACT,UAAU;gBACV,WAAU;;kCAEV,qQAAC,6OAAQ;wBAAC,MAAM;;;;;;oBACf,cAAc,iBAAiB;;;;;;;YAGnC,6BACG,qQAAC;gBAAI,WAAU;;kCACX,qQAAC;wBAAI,WAAU;;;;;;kCACf,qQAAC;kCAAK;;;;;;;;;;;;;;;;;;AAK1B"}},
    {"offset": {"line": 641, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/src/components/settings/EmergencyImportSection.tsx"],"sourcesContent":["import { useState, useRef } from 'react';\r\nimport { Upload, AlertTriangle } from 'lucide-react';\r\nimport { importFromFile } from '@/lib/exportImport';\r\nimport { useProfileStore } from '@/store/useProfileStore';\r\nimport { useToast } from '@/hooks/useToast';\r\n\r\nexport function EmergencyImportSection() {\r\n    const [isImporting, setIsImporting] = useState(false);\r\n    const [showConfirmDialog, setShowConfirmDialog] = useState(false);\r\n    const [selectedFile, setSelectedFile] = useState<File | null>(null);\r\n    const fileInputRef = useRef<HTMLInputElement>(null);\r\n    const { currentProfile } = useProfileStore();\r\n    const toast = useToast();\r\n\r\n    const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {\r\n        const file = event.target.files?.[0];\r\n        if (file) {\r\n            setSelectedFile(file);\r\n            setShowConfirmDialog(true);\r\n        }\r\n    };\r\n\r\n    const handleCancelImport = () => {\r\n        setShowConfirmDialog(false);\r\n        setSelectedFile(null);\r\n        if (fileInputRef.current) {\r\n            fileInputRef.current.value = '';\r\n        }\r\n    };\r\n\r\n    const handleConfirmImport = async () => {\r\n        if (!currentProfile || !selectedFile) {\r\n            toast.error('No active profile or file selected');\r\n            return;\r\n        }\r\n\r\n        setShowConfirmDialog(false);\r\n        setIsImporting(true);\r\n\r\n        try {\r\n            await importFromFile(selectedFile, currentProfile.id);\r\n            toast.success('Data restored successfully! Refreshing...');\r\n\r\n            // Reload page to refresh UI with new data\r\n            setTimeout(() => {\r\n                window.location.reload();\r\n            }, 1500);\r\n        } catch (error) {\r\n            console.error('Import error:', error);\r\n            toast.error(`Import failed: ${(error as Error).message}`);\r\n        } finally {\r\n            setIsImporting(false);\r\n            setSelectedFile(null);\r\n            if (fileInputRef.current) {\r\n                fileInputRef.current.value = '';\r\n            }\r\n        }\r\n    };\r\n\r\n    return (\r\n        <>\r\n            <div className=\"glass rounded-lg p-6 border-2 border-warn\">\r\n                <div className=\"flex items-start gap-3 mb-4\">\r\n                    <AlertTriangle className=\"text-warn mt-1 flex-shrink-0\" size={24} />\r\n                    <div>\r\n                        <h2 className=\"text-xl font-semibold text-text-primary mb-2\">\r\n                            Emergency Import (Destructive)\r\n                        </h2>\r\n                        <p className=\"text-text-muted text-sm mb-2\">\r\n                            Restore all data from a backup ZIP file.\r\n                        </p>\r\n                        <p className=\"text-warn text-sm font-semibold\">\r\n                            ‚ö†Ô∏è WARNING: This will DELETE all existing data and replace it with the backup.\r\n                        </p>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"flex items-center gap-4\">\r\n                    <label htmlFor=\"import-file\" className=\"btn-secondary flex items-center gap-2 cursor-pointer\">\r\n                        <Upload size={18} />\r\n                        {isImporting ? 'Importing...' : 'Select Backup File'}\r\n                        <input\r\n                            ref={fileInputRef}\r\n                            id=\"import-file\"\r\n                            type=\"file\"\r\n                            accept=\".zip\"\r\n                            onChange={handleFileSelect}\r\n                            disabled={isImporting}\r\n                            className=\"hidden\"\r\n                        />\r\n                    </label>\r\n                </div>\r\n\r\n                {isImporting && (\r\n                    <div className=\"mt-4 flex items-center gap-2 text-text-muted text-sm\">\r\n                        <div className=\"animate-spin h-4 w-4 border-2 border-accent-primary border-t-transparent rounded-full\" />\r\n                        <span>Restoring data from backup...</span>\r\n                    </div>\r\n                )}\r\n            </div>\r\n\r\n            {/* Confirmation Dialog */}\r\n            {showConfirmDialog && (\r\n                <div className=\"fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4\">\r\n                    <div className=\"glass rounded-lg p-6 max-w-md w-full border-2 border-warn\">\r\n                        <div className=\"flex items-start gap-3 mb-4\">\r\n                            <AlertTriangle className=\"text-warn flex-shrink-0\" size={32} />\r\n                            <div>\r\n                                <h3 className=\"text-lg font-semibold text-text-primary mb-2\">\r\n                                    Confirm Destructive Import\r\n                                </h3>\r\n                                <p className=\"text-text-muted text-sm mb-2\">\r\n                                    You are about to import:\r\n                                </p>\r\n                                <p className=\"text-accent-primary text-sm font-mono bg-bg-tertiary px-2 py-1 rounded mb-3\">\r\n                                    {selectedFile?.name}\r\n                                </p>\r\n                                <p className=\"text-warn text-sm font-semibold mb-2\">\r\n                                    This will:\r\n                                </p>\r\n                                <ul className=\"text-warn text-sm list-disc list-inside space-y-1 mb-3\">\r\n                                    <li>Delete ALL existing workspaces</li>\r\n                                    <li>Delete ALL existing prompts</li>\r\n                                    <li>Delete ALL existing categories</li>\r\n                                    <li>Delete ALL existing keywords</li>\r\n                                    <li>Replace with backup data</li>\r\n                                </ul>\r\n                                <p className=\"text-text-muted text-sm\">\r\n                                    This action cannot be undone unless you have another backup.\r\n                                </p>\r\n                            </div>\r\n                        </div>\r\n\r\n                        <div className=\"flex gap-3 justify-end\">\r\n                            <button\r\n                                onClick={handleCancelImport}\r\n                                className=\"btn-secondary\"\r\n                            >\r\n                                Cancel\r\n                            </button>\r\n                            <button\r\n                                onClick={handleConfirmImport}\r\n                                className=\"bg-warn hover:bg-warn/80 text-white px-4 py-2 rounded-lg font-medium transition-colors\"\r\n                            >\r\n                                Yes, Delete & Import\r\n                            </button>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n            )}\r\n        </>\r\n    );\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 984, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/src/components/settings/SettingsTabs.tsx"],"sourcesContent":["'use client';\r\n\r\nimport Link from 'next/link';\r\nimport { usePathname } from 'next/navigation';\r\nimport { Settings, Key } from 'lucide-react';\r\nimport { motion } from 'framer-motion';\r\n\r\nexport function SettingsTabs() {\r\n    const pathname = usePathname();\r\n\r\n    const tabs = [\r\n        {\r\n            path: '/settings/variable-defaults',\r\n            label: 'Variable Defaults',\r\n            icon: Settings,\r\n        },\r\n        {\r\n            path: '/settings/api',\r\n            label: 'API Keys',\r\n            icon: Key,\r\n        },\r\n    ];\r\n\r\n    return (\r\n        <div className=\"border-b border-white/10 mb-8\">\r\n            <div className=\"flex gap-1\">\r\n                {tabs.map((tab) => {\r\n                    const isActive = pathname === tab.path;\r\n                    const Icon = tab.icon;\r\n\r\n                    return (\r\n                        <Link\r\n                            key={tab.path}\r\n                            href={tab.path}\r\n                            className=\"relative\"\r\n                        >\r\n                            <motion.div\r\n                                whileHover={{ y: -2 }}\r\n                                className={`\r\n                                    flex items-center gap-2 px-6 py-3 rounded-t-xl transition-colors\r\n                                    ${isActive\r\n                                        ? 'bg-white/5 text-primary border-b-2 border-primary'\r\n                                        : 'text-secondary hover:text-primary hover:bg-white/5'\r\n                                    }\r\n                                `}\r\n                            >\r\n                                <Icon className=\"w-4 h-4\" />\r\n                                <span className=\"font-medium\">{tab.label}</span>\r\n                            </motion.div>\r\n                        </Link>\r\n                    );\r\n                })}\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\n"],"names":[],"mappings":";;;;;AAEA;AACA;AACA;AAAA;AACA;AALA;;;;;;AAOO,SAAS;IACZ,MAAM,WAAW,IAAA,wKAAW;IAE5B,MAAM,OAAO;QACT;YACI,MAAM;YACN,OAAO;YACP,MAAM,6OAAQ;QAClB;QACA;YACI,MAAM;YACN,OAAO;YACP,MAAM,8NAAG;QACb;KACH;IAED,qBACI,qQAAC;QAAI,WAAU;kBACX,cAAA,qQAAC;YAAI,WAAU;sBACV,KAAK,GAAG,CAAC,CAAC;gBACP,MAAM,WAAW,aAAa,IAAI,IAAI;gBACtC,MAAM,OAAO,IAAI,IAAI;gBAErB,qBACI,qQAAC,8LAAI;oBAED,MAAM,IAAI,IAAI;oBACd,WAAU;8BAEV,cAAA,qQAAC,2NAAM,CAAC,GAAG;wBACP,YAAY;4BAAE,GAAG,CAAC;wBAAE;wBACpB,WAAW,CAAC;;oCAER,EAAE,WACI,sDACA,qDACL;gCACL,CAAC;;0CAED,qQAAC;gCAAK,WAAU;;;;;;0CAChB,qQAAC;gCAAK,WAAU;0CAAe,IAAI,KAAK;;;;;;;;;;;;mBAfvC,IAAI,IAAI;;;;;YAmBzB;;;;;;;;;;;AAIhB"}},
    {"offset": {"line": 1075, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/src/page-components/Settings.tsx"],"sourcesContent":["import { EmergencyExportSection } from '@/components/settings/EmergencyExportSection';\r\nimport { EmergencyImportSection } from '@/components/settings/EmergencyImportSection';\r\nimport { SettingsTabs } from '@/components/settings/SettingsTabs';\r\n\r\nexport function Settings() {\r\n    return (\r\n        <div className=\"max-w-4xl mx-auto space-y-6\">\r\n            <h1 className=\"text-3xl font-bold text-text-primary mb-6\">Settings</h1>\r\n\r\n            <SettingsTabs />\r\n\r\n            <div className=\"space-y-6\">\r\n                <EmergencyExportSection />\r\n                <EmergencyImportSection />\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;;;;;AAEO,SAAS;IACZ,qBACI,qQAAC;QAAI,WAAU;;0BACX,qQAAC;gBAAG,WAAU;0BAA4C;;;;;;0BAE1D,qQAAC,qLAAY;;;;;0BAEb,qQAAC;gBAAI,WAAU;;kCACX,qQAAC,yMAAsB;;;;;kCACvB,qQAAC,yMAAsB;;;;;;;;;;;;;;;;;AAIvC"}},
    {"offset": {"line": 1134, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Sande/OneDrive/Documents/GitHub/botbrains/botbrains-nextjs/app/%28authenticated%29/settings/page.tsx"],"sourcesContent":["'use client';\r\n\r\nimport { Settings } from '@/page-components/Settings';\r\n\r\nexport default function SettingsPage() {\r\n    return <Settings />;\r\n}\r\n"],"names":[],"mappings":";;;;;AAEA;AAFA;;;AAIe,SAAS;IACpB,qBAAO,qQAAC,yKAAQ;;;;;AACpB"}}]
}